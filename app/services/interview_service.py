"""
Interview Service
Business logic layer for interview persistence operations
"""
from typing import Tuple, List, Optional
from uuid import UUID
from datetime import datetime
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.db_models import Interview, InterviewMessage, InterviewStatusEnum, MessageRoleEnum, LanguageEnum
from app.models.interview import (
    InterviewDBResponse,
    InterviewWithMessages,
    MessageResponse,
    InterviewFilters,
    PaginationParams,
    PaginationMeta,
    ConversationMessage
)
from app.repositories.interview_repository import InterviewRepository
from app.repositories.message_repository import MessageRepository
from app.services.context_service import get_context_service


class InterviewService:
    """Service for interview business logic and persistence"""
    
    def __init__(self, db: AsyncSession):
        """
        Initialize service with database session
        
        Args:
            db: Async SQLAlchemy session
        """
        self.db = db
        self.interview_repo = InterviewRepository(db)
        self.message_repo = MessageRepository(db)
        self.context_service = get_context_service()
    
    async def start_interview(
        self,
        employee_id: UUID,
        language: str,
        technical_level: str,
        first_question: str
    ) -> Tuple[Interview, InterviewMessage]:
        """
        Create a new interview and save the first question from the agent
        
        Args:
            employee_id: Employee UUID
            language: Interview language (es/en/pt)
            technical_level: User's technical level
            first_question: First question generated by the agent
            
        Returns:
            Tuple of (Interview, InterviewMessage)
            
        Raises:
            Exception: If employee_id doesn't exist or database error occurs
        """
        # Validate that employee exists by calling context service
        user_context = await self.context_service.get_user_context(str(employee_id))
        if not user_context or not user_context.get("id"):
            raise ValueError(f"Employee with ID {employee_id} not found")
        
        # Create Interview record
        # Normalize language to lowercase to match enum values
        language_lower = language.lower()
        
        # Validate language
        if language_lower not in ["es", "en", "pt"]:
            raise ValueError(f"Invalid language: {language}. Must be one of: es, en, pt")
        
        # Pass string values directly to match PostgreSQL enum values
        interview = Interview(
            employee_id=employee_id,
            language=language_lower,  # Pass string directly: "es", "en", or "pt"
            technical_level=technical_level,
            status=InterviewStatusEnum.in_progress,  # Use lowercase enum name
            started_at=datetime.utcnow()
        )
        interview = await self.interview_repo.create(interview)
        
        # Create first message (assistant role, sequence 1)
        first_message = InterviewMessage(
            interview_id=interview.id_interview,
            role=MessageRoleEnum.assistant,  # Use lowercase enum name
            content=first_question,
            sequence_number=1
        )
        first_message = await self.message_repo.create(first_message)
        
        return interview, first_message
    
    async def continue_interview(
        self,
        interview_id: UUID,
        employee_id: UUID,
        user_response: str,
        agent_question: str,
        is_final: bool = False
    ) -> Tuple[Interview, InterviewMessage, InterviewMessage]:
        """
        Save user response and agent's next question
        
        Args:
            interview_id: Interview UUID
            employee_id: Employee UUID (for authorization)
            user_response: User's response to previous question
            agent_question: Agent's next question
            is_final: Whether this is the final question
            
        Returns:
            Tuple of (Interview, user_message, agent_message)
            
        Raises:
            ValueError: If interview not found or access denied
        """
        # Validate that interview belongs to employee
        interview = await self.interview_repo.get_by_id(interview_id, employee_id)
        if not interview:
            raise ValueError(f"Interview {interview_id} not found or access denied")
        
        # Get last sequence number
        last_sequence = await self.message_repo.get_last_sequence(interview_id)
        
        # Create user message (sequence_number + 1)
        user_message = InterviewMessage(
            interview_id=interview_id,
            role=MessageRoleEnum.user,  # Use lowercase enum name
            content=user_response,
            sequence_number=last_sequence + 1
        )
        user_message = await self.message_repo.create(user_message)
        
        # Create agent message (sequence_number + 2)
        agent_message = InterviewMessage(
            interview_id=interview_id,
            role=MessageRoleEnum.assistant,  # Use lowercase enum name
            content=agent_question,
            sequence_number=last_sequence + 2
        )
        agent_message = await self.message_repo.create(agent_message)
        
        # Update interview updated_at timestamp
        interview.updated_at = datetime.utcnow()
        
        # If final, mark interview as completed
        if is_final:
            interview = await self.interview_repo.mark_completed(interview_id)
        
        await self.db.flush()
        await self.db.refresh(interview)
        
        return interview, user_message, agent_message
    
    async def get_interview(
        self,
        interview_id: UUID,
        employee_id: UUID
    ) -> Optional[InterviewWithMessages]:
        """
        Get interview with full message history
        
        Args:
            interview_id: Interview UUID
            employee_id: Employee UUID (for authorization)
            
        Returns:
            InterviewWithMessages or None if not found
        """
        # Get interview with messages (repository already validates employee_id)
        interview = await self.interview_repo.get_by_id(interview_id, employee_id)
        if not interview:
            return None
        
        # Get messages ordered by sequence_number
        messages = await self.message_repo.get_by_interview(interview_id)
        
        # Convert to response models
        message_responses = [
            MessageResponse(
                id_message=str(msg.id_message),
                role=msg.role.value,
                content=msg.content,
                sequence_number=msg.sequence_number,
                created_at=msg.created_at
            )
            for msg in messages
        ]
        
        return InterviewWithMessages(
            id_interview=str(interview.id_interview),
            employee_id=str(interview.employee_id),
            language=interview.language.value,
            technical_level=interview.technical_level,
            status=interview.status.value,
            started_at=interview.started_at,
            completed_at=interview.completed_at,
            total_messages=len(messages),
            messages=message_responses
        )
    
    async def list_interviews(
        self,
        employee_id: UUID,
        filters: InterviewFilters,
        pagination: PaginationParams,
        organization_id: Optional[str] = None,
        scope: str = "own"
    ) -> Tuple[List[InterviewDBResponse], PaginationMeta]:
        """
        List interviews with filters and pagination
        
        Args:
            employee_id: Employee UUID
            filters: Filter parameters (status, language, dates)
            pagination: Pagination parameters (page, page_size)
            organization_id: Organization ID for organization-wide queries (optional)
            scope: Query scope - "own" for employee's interviews, "organization" for all
            
        Returns:
            Tuple of (list of InterviewDBResponse, PaginationMeta)
        """
        # Get interviews from repository based on scope
        if scope == "organization" and organization_id:
            interviews, total_count = await self.interview_repo.get_by_organization(
                organization_id=organization_id,
                status=filters.status,
                language=filters.language,
                start_date=filters.start_date,
                end_date=filters.end_date,
                page=pagination.page,
                page_size=pagination.page_size
            )
        else:
            interviews, total_count = await self.interview_repo.get_by_employee(
                employee_id=employee_id,
                status=filters.status,
                language=filters.language,
                start_date=filters.start_date,
                end_date=filters.end_date,
                page=pagination.page,
                page_size=pagination.page_size
            )
        
        # Convert to response models
        interview_responses = []
        for interview in interviews:
            # Count messages for each interview
            message_count = await self.message_repo.count_by_interview(interview.id_interview)
            
            interview_responses.append(
                InterviewDBResponse(
                    id_interview=str(interview.id_interview),
                    employee_id=str(interview.employee_id),
                    language=interview.language.value,
                    technical_level=interview.technical_level,
                    status=interview.status.value,
                    started_at=interview.started_at,
                    completed_at=interview.completed_at,
                    total_messages=message_count
                )
            )
        
        # Calculate pagination metadata
        total_pages = (total_count + pagination.page_size - 1) // pagination.page_size
        pagination_meta = PaginationMeta(
            total_items=total_count,
            total_pages=total_pages,
            current_page=pagination.page,
            page_size=pagination.page_size
        )
        
        return interview_responses, pagination_meta
